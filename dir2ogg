#!/usr/bin/python
#
# Copyright (C) 2007 Julian Andres Klode <jak@jak-linux.org>
# Copyright (C) 2003-2006 Darren Kirby <d@badcomputer.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

'''
dir2ogg converts mp3, m4a, and wav files to the free open source OGG format. Oggs are
about 20-25% smaller than mp3s with the same relative sound quality. Your mileage may vary.

Keep in mind that converting from mp3 or m4a to ogg is a conversion between two lossy formats.
This is fine if you just want to free up some disk space, but if you're a hard-core audiophile
you may be dissapointed. I really can't notice a difference in quality with 'naked' ears myself.

This script converts mp3s to wavs using mpg123 then converts the wavs to oggs using oggenc.
m4a conversions require faad. Id3 tag support requires mutagen for mp3s.
Scratch tags using the filename will be written for wav files (and mp3s with no tags!)
'''

import sys
import os, os.path
from fnmatch import filter, fnmatch
from optparse import OptionParser
from subprocess import Popen, call, PIPE

__version__ = '0.11 Beta 1'
__date__    = '2007-09-30'

class MyConfig:
    def __init__(self):
        if not '--version' in sys.argv:
            showBanner()
        if  '-f' in sys.argv:
            fatal('-f is deprecated and its behavior will change in 0.12. Please use -W in future')
        if len(sys.argv[1:]) == 0:
            fatal('No arguments specified, see --help for usage.')
        parser = OptionParser(usage='%prog [options] [arguments]', version='%prog ' + __version__)
        parser.add_option('-l', '--license',action='callback', callback=showLicense, help='display license informations')
        parser.add_option('-d', '--directory', action='store_true', help='convert files in all directories specified as arguments')
        parser.add_option('-r', '--recursive', action='store_true', help='convert files in all subdirectories of all directories specified as arguments')
        parser.add_option('-c', '--cdda', action='store_true', help="convert audio cd in all devices specified as arguments (or default: /dev/cdrom) [EXPERIMENTAL]")
        parser.add_option('-q', '--quality', metavar='N', default=3.0, type='float', help='quality. N is a number from 1-10 (default %default)')
        parser.add_option('-n', '--no-mp3', dest='convert_mp3', action='store_false', default=True, help="don't convert mp3s (use with '-d' or '-r')")
        parser.add_option('--convert-flac',action='store_true', help="convert flac files (use with '-d')")
        parser.add_option('-m', '--convert-m4a', action='store_true', help="convert m4a files (use with '-d')")
        parser.add_option('-w', '--convert-wav', action='store_true', help="convert wav files (use with '-d')")
        parser.add_option('-W', '--convert-wma', action='store_true', help="convert wma files (use with '-d').")
        parser.add_option('--delete-input', action='store_true', help='delete input files')
        parser.add_option('-p', '--preserve-wav',action='store_true', help='keep the wav files (also includes -P)')
        parser.add_option('-P', '--no-pipe',action='store_true', help='Do not use pipes, use temporary wav files')
        parser.add_option('-v', '--verbose',action='store_true', help='verbose output')
        # Setup decoders
        commands = {'mp3': ('lame', 'mpg123', 'mpg321', 'mplayer'),
            'wma': ('mplayer',),
            'm4a': ('faad', 'mplayer'),
            'flac': ('flac', 'ogg123', 'mplayer'),
            'cd':  ('cdparanoia', 'icedax','cdda2wav', 'mplayer'),
            }
        for ext, dec in commands.items():
            default, choices = None, []
            for command in dec:
                a = [prefix for prefix in os.environ['PATH'].split(os.pathsep) if os.path.exists(os.path.join(prefix, command))]
                if a:
                    choices.append(command)
                    default = default or command
            parser.add_option('--' + ext + '-decoder', type="choice", metavar=default, default=default, choices=choices, help="decoder for %s files (choices: %s)" % (ext, ', '.join(choices)))
        # End of decoder options
        options, self.args = parser.parse_args()
        if filter(self.args, '*.[mM][pP]3') :
            options.convert_mp3 = True
        elif filter(self.args, '*.[mM]4[aA]'):
            options.convert_m4a = True
        elif filter(self.args, '*.[wW][mM][aA]'):
            options.convert_wma = True
        elif filter(self.args, '*.[fF][lL][aA][cC]'):
            options.convert_flac = True
        self.__dict__.update(options.__dict__)
        self.convert_cd = self.cdda

        # Check for missing decoders
        for ext in commands:
            if self.__dict__["convert_" + ext] and not self.__dict__[ext + '_decoder']:
                fatal('%s was enabled, but no decoder has been found.' % ext)

        if len(self.args) == 0 and not self.cdda:
            fatal('No files/directories specified.')



def info(msg):
    print 'I: %s' % msg

def warn(msg, i="W:", e=''):
    '''print errors to the screen (red)'''
    call(['echo', '-en', '\\033[1;31m'])
    print >> sys.stderr, "%s %s %s" % (i, msg, e)
    call(['echo', '-en', '\\033[0;39m'])

def fatal(msg):
    '''Fatal error (error + exit)'''
    warn(msg, 'E:', 'Exiting...')
    sys.exit(1)
error = warn

def returnDirs(root):
    mydirs = {}
    for pdir, dirs, files in os.walk(root):
        if not pdir in mydirs:
            mydirs[pdir] = files
    return mydirs

class Id3TagHandler:
    '''Class for handling meta-tags. (Needs mutagen)'''
    accept = ['album', 'album_subtitle', 'albumartist', 'albumartistsort', 
              'albumsort', 'artist', 'artistsort', 'asin', 'bpm', 'comment',
              'compilation', 'composer', 'composersort', 'conductor', 'copyright',
              'date', 'discid', 'discnumber', 'encodedby', 'engineer', 'gapless',
              'genre', 'grouping', 'isrc', 'label', 'lyricist', 'lyrics', 'mood',
              'musicbrainz_albumartistid', 'musicbrainz_albumid', 'musicbrainz_artistid',
              'musicbrainz_discid', 'musicbrainz_sortname', 'musicbrainz_trackid',
              'musicbrainz_trmid', 'musicip_puid', 'podcast', 'podcasturl',
              'releasecountry', 'musicbrainz_albumstatus', 'musicbrainz_albumtype', 'remixer', 'show',
              'showsort', 'subtitle', 'title', 'titlesort', 'tracknumber', 'tracktotal']
    tags   = {}
    def grabCommon(self, handler, convert={}):
        '''Common grabber, starts the handler and applies the tags to self.tags'''
        mydict = handler(self.song)
        for k,v in mydict.items():
            k = k.lower()
            k = k in convert and convert[k] or k
            if k in self.accept:
                self.tags[k] = v
            else:
                print k

    def grabM4ATags(self):
        '''Import MP4 tags handler, set convert and call commonGrab'''
        convert = {'----:com.apple.iTunes:ASIN': 'asin',
                   '----:com.apple.iTunes:MusicBrainz Album Artist Id': 'musicbrainz_albumartistid',
                   '----:com.apple.iTunes:MusicBrainz Album Id': 'musicbrainz_albumid',
                   '----:com.apple.iTunes:MusicBrainz Album Release Country': 'releasecountry',
                   '----:com.apple.iTunes:MusicBrainz Album Status': 'musicbrainz_albumstatus',
                   '----:com.apple.iTunes:MusicBrainz Album Type': 'musicbrainz_albumtype',
                   '----:com.apple.iTunes:MusicBrainz Artist Id': 'musicbrainz_artistid',
                   '----:com.apple.iTunes:MusicBrainz Disc Id': 'musicbrainz_discid',
                   '----:com.apple.iTunes:MusicBrainz TRM Id': 'musicbrainz_trmid',
                   '----:com.apple.iTunes:MusicBrainz Track Id': 'musicbrainz_trackid',
                   '----:com.apple.iTunes:MusicIP PUID': 'musicip_puid',
                   'aART': 'albumartist', 'cpil': 'compilation', 'cprt': 'copyright',
                   'pcst': 'podcast', 'pgap': 'gapless', 'purl': 'podcasturl',
                   'soaa': 'albumartistsort', 'soal': 'albumsort', 'soar': 'artistsort',
                   'soco': 'composersort', 'sonm': 'titlesort', 'sosn': 'showsort',
                   'trkn': 'tracknumber', 'tvsh': 'show', '\xa9ART': 'artist',
                   '\xa9alb': 'album', '\xa9cmt': 'comment', '\xa9day': 'date',
                   '\xa9gen': 'genre', '\xa9grp': 'grouping', '\xa9lyr': 'lyrics',
                   '\xa9nam': 'title', '\xa9too': 'encodedby','\xa9wrt': 'composer'}
        try:
            from mutagen.mp4 import MP4
        except ImportError:
            from mutagen.m4a import M4A as MP4
        self.grabCommon(MP4, convert)

    def grabWMATags(self):
        '''Import ASF tags handler, set convert and call commonGrab'''
        convert = {'Author': 'artist', 'Description': 'comment',
                   'MusicBrainz/Album Artist Id': 'musicbrainz_albumartistid',
                   'MusicBrainz/Album Id': 'musicbrainz_albumid',
                   'MusicBrainz/Album Release Country': 'releasecountry',
                   'MusicBrainz/Album Status': 'musicbrainz_albumstatus',
                   'MusicBrainz/Album Type': 'musicbrainz_albumtype',
                   'MusicBrainz/Artist Id': 'musicbrainz_artistid',
                   'MusicBrainz/Disc Id': 'musicbrainz_discid',
                   'MusicBrainz/TRM Id': 'musicbrainz_trmid',
                   'MusicBrainz/Track Id': 'musicbrainz_trackid',
                   'MusicIP/PUID': 'musicip_puid',
                   'WM/AlbumArtist': 'albumartist',
                   'WM/AlbumArtistSortOrder': 'albumartistsort',
                   'WM/AlbumSortOrder': 'albumsort',
                   'WM/AlbumTitle': 'album',
                   'WM/ArtistSortOrder': 'artistsort',
                   'WM/BeatsPerMinute': 'bpm',
                   'WM/Composer': 'composer',
                   'WM/Conductor': 'conductor',
                   'WM/ContentGroupDescription': 'grouping',
                   'WM/Copyright': 'copyright',
                   'WM/EncodedBy': 'encodedby',
                   'WM/Genre': 'genre',
                   'WM/ISRC': 'isrc',
                   'WM/Lyrics': 'lyrics',
                   'WM/ModifiedBy': 'remixer',
                   'WM/Mood': 'mood',
                   'WM/PartOfSet': 'discnumber',
                   'WM/Producer': 'engineer',
                   'WM/Publisher': 'label',
                   'WM/SetSubTitle': 'album_subtitle',
                   'WM/SubTitle': 'subtitle',
                   'WM/TitleSortOrder': 'titlesort',
                   'WM/TrackNumber': 'tracknumber',
                   'WM/Writer': 'lyricist',
                   'WM/Year': 'date',
                  }
        from mutagen.asf import ASF
        self.grabCommon(ASF, convert)

    def grabFLACTags(self):
        '''Import MP3 tags handler, and call commonGrab'''
        from mutagen.flac import FLAC
        self.grabCommon(FLAC)

    def grabMP3Tags(self):
        '''Import MP3 tags handler, and call commonGrab'''
        from mutagen.easyid3 import EasyID3
        self.grabCommon(EasyID3)

    def listIfVerbose(self):
        info('Meta-tags I will write:')
        for k,v in self.tags.items():
            if type(v) == list:
                info(k + ': ' + ','.join(v))
            else:
                info(k + ': ' + v)

class Convert(Id3TagHandler):
    '''
    Base conversion Class.

    __init__ creates some useful attributes,
    grabs the id3 tags, and sets a flag to remove files.
    Methods are the conversions we can do
    '''

    def __init__(self, song, conf):
        self.device  = ""
        self.track   = ""
        self.song    = song
        self.conf    = conf
        songRoot     = os.path.splitext(song)[0] + "."
        self.songwav = songRoot + 'wav'
        self.songogg = songRoot + 'ogg'
        self.BUFFER  = '#' * 78
        if fnmatch(self.song, '*.[mM][pP]3') :
            self.decoder = self.conf.mp3_decoder
            self.grabMP3Tags()
        elif fnmatch(self.song, '*.[mM]4[aA]'):
            self.decoder = self.conf.m4a_decoder
            self.grabM4ATags()
        elif fnmatch(self.song, '*.[wW][mM][aA]'):
            self.decoder = self.conf.wma_decoder
            self.grabWMATags()
        elif fnmatch(self.song, '*.[fF][lL][aA][cC]'):
            self.decoder = self.conf.flac_decoder
            self.grabFLACTags()
        self.convert()

    def decode(self):
        if self.decoder not in ('mplayer', 'cd-mplayer', 'cd-icedax', 'cd-cdda2wav') and not self.conf.no_pipe and not self.conf.preserve_wav:
            outfile, outfile1 = '-', '/dev/stdout'
            use_pipe = 1
        else:
            outfile = outfile1 = self.songwav
            use_pipe = 0
        decoder            = {}
        decoder['mpg123']  = ['mpg123', '-w', outfile, self.song]
        decoder['mpg321']  = ['mpg321', '-w', outfile, self.song]
        decoder['faad']    = ['faad',  '-o' , outfile1, self.song]
        decoder['ogg123']  = ['ogg123', '-dwav', '-f' , outfile, self.song]
        decoder['flac']    = ['flac', '-o', outfile, '-d', self.song]
        decoder['lame']    = ['lame', '--quiet', '--decode', self.song, outfile]
        decoder['mplayer'] = ['mplayer', '-vo', 'null', '-vc' ,'dummy', '-af', 'resample=44100', '-ao', 'pcm:file=' + outfile, self.song]
        # CD Ripper
        decoder['cd-cdparanoia'] = ['cdparanoia', '-Y', '-q',  '-w', '-d', self.device, str(self.track), outfile]
        decoder['cd-icedax']     = ['icedax', '-H', '-t', str(self.track), '-D',self.device]
        decoder['cd-cdda2wav']   = ['cdda2wav', '-H', '-t', str(self.track), '-D',self.device]
        decoder['cd-mplayer']    = ['mplayer', '-vo', 'null', '-vc' ,'dummy', '-af', 'resample=44100', '-ao', 'pcm:file=' + outfile, '-cdrom-device', self.device, "cdda://" + str(self.track)]
        if use_pipe:
            return True, Popen(decoder[self.decoder], stdout=PIPE)
        else:
            decoder['cd-cdparanoia'].remove('-q')
            decoder['lame'].remove('--quiet')
            retcode = call(decoder[self.decoder])
            if retcode != 0:
                return (False, None)
            else:
                return (True, None)

    def convert(self):
        ''' Convert wav -> ogg.'''
        if self.songwav == self.song:
            ok = True
            dec = None
        else:
            ok, dec = self.decode()
        if not ok:
            error('Decoding of "%s" failed.' % self.song)
            return

        if dec:
            enc = Popen(['oggenc', '-o', self.songogg, '-q', str(self.conf.quality), '-'], stdin=dec.stdout)
            enc.communicate()
            dec.wait()
            if dec.returncode < 0:
                error('Decoding of "%s" failed.' % self.song)
                return False
            elif enc.returncode < 0:
                error('Encoding of "%s" failed.' % self.song)
                return False
        else:
            enc = call(['oggenc', '-o', self.songogg, '-q', str(self.conf.quality), self.songwav])
            if enc != 0:
                error('Encoding of "%s" failed.' % self.songwav)
                return False
            elif not self.conf.preserve_wav and self.song != self.songwav:
                os.remove(self.songwav)
        if self.tags != {}:
            try:
                # Add tags to the ogg file
                from mutagen.oggvorbis import OggVorbis
                myogg = OggVorbis(self.songogg)
                myogg.update(self.tags)
                myogg.save()
            except:
                error('Could not save the tags')
                return False
        else:
            warn('No tags found...')

        if self.conf.delete_input:
            os.remove(self.song)
        return True

class ConvertTrack(Convert):
    '''Wrapper around Convert for CD Tracks'''
    def __init__(self, device, conf, track, tags):
        self.device, self.track, self.tags, self.conf = device, track, tags, conf
        self.song    = ''
        self.songwav = "audio.wav"
        self.songogg = "%(artist)s/%(album)s/%(ntracknumber)s - %(title)s.ogg" % tags
        self.conf.preserve_wav = False
        self.decoder           = 'cd-' + self.conf.cd_decoder
        self.convert()

class ConvertDisc:
    '''Wrapper around ConvertTrack to Convert complete cds
    Currently uses MusicBrainz, but a CDDB fallback will be added, too.'''
    def __init__(self, dev, conf):
        self.dev, self.conf = dev, conf
        try:
            self.MusicBrainz()
        except self.MBError:
            warn('MusicBrainz failed. Trying FreeDB...')
            self.CDDB()

    class MBError(Exception):
        '''Empty'''

    def CDDB(self):
        try:
            import CDDB, DiscID
        except ImportError:
            fatal('You need python-cddb (http://cddb-py.sf.net) to convert cds. Please install it.')

        disc_id = DiscID.disc_id(DiscID.open(self.dev))
        (query_status, query_info) = CDDB.query(disc_id)
        if type(query_info) == list:
            query_info = query_info[0]
        (read_status, read_info) = CDDB.read(query_info['category'], query_info['disc_id'])

        for i in range(disc_id[1]):
            title           = {}
            title['discid'] = query_info['disc_id']
            title['artist'],title['album'] = (i.strip() for i in query_info['title'].split("/"))
            title['genre']  = read_info['DGENRE']
            title['date']   = read_info['DYEAR']
            title['title']  = read_info['TTITLE' + str(i)]          
            title['tracktotal'] = str(len(range(disc_id[1])) + 1)
            title['ntracknumber'] = '0' * (len(title['tracktotal'] ) - len(str(i+1)) ) + str(i+1)
            title['tracknumber'] = str(i+1)
            for k, v in title.items():
                title[k] =  unicode(str(v), "ISO-8859-1")
            ConvertTrack(self.dev, self.conf, i+1, title)
            
    def MusicBrainz(self):
        try:
            import musicbrainz2.disc as mbdisc
            import musicbrainz2.webservice as mbws
        except ImportError, e:
            error('You need python-musicbrainz2 to convert cds. Please install it. Trying cddb.')
            raise self.MBError, e

        service = mbws.WebService()
        query = mbws.Query(service)

        # Read the disc in the drive
        try:
            disc = mbdisc.readDisc(self.dev)
        except mbdisc.DiscError, e:
            print "Error:", e
            raise self.MBError

        discId = disc.getId()
        try:
            myfilter = mbws.ReleaseFilter(discId=discId)
            results = query.getReleases(myfilter)
        except mbws.WebServiceError, e:
            print "Error:", e
            raise self.MBError

        if len(results) == 0:
            print "Disc is not yet in the MusicBrainz database."
            print "Consider adding it via", mbdisc.getSubmissionUrl(disc)
            raise self.MBError
        try:
            inc = mbws.ReleaseIncludes(artist=True, tracks=True, releaseEvents=True)
            release = query.getReleaseById(results[0].release.getId(), inc)
        except mbws.WebServiceError, e:
            print "Error:", e
            raise self.MBError
            
        isSingleArtist = release.isSingleArtistRelease()
        
        try:
            # try to get the CDDB ID
            import DiscID
            cddb_id = '%08lx' % long(DiscID.disc_id(DiscID.open(self.dev))[0])
        except:
            cddb_id = False

        i = 1
        for t in release.tracks:
            title           = {}
            title['artist'] = isSingleArtist and release.artist.name or t.artist
            if cddb_id:
                title['discid'] = cddb_id
            title['album']  = release.title
            title['date']   = release.getEarliestReleaseDate()
            title['musicbrainz_albumartistid'] = release.artist.id.split("/")[-1]
            title['musicbrainz_albumid'] = release.id.split("/")[-1]
            title['musicbrainz_discid'] = discId
            title['musicbrainz_sortname'] = release.artist.sortName
            title['musicbrainz_trackid'] = t.id.split("/")[-1]
            title['title']  = t.title
            title['tracktotal'] = str(len(release.tracks))
            title['ntracknumber'] = '0' * ( len(title['tracktotal']) - len(str(i)) ) + str(i)
            title['tracknumber'] = str(i)
            ConvertTrack(self.dev, self.conf, i, title)
            i+=1

class ConvertDirectory:
    '''
    This class is just a wrapper for Convert.
    
    Grab the songs to convert, then feed them one
    by one to the Convert class.
    '''

    def __init__(self, conf, d, files=None):
        ''' Decide which files will be converted.'''
        if os.path.exists(d) == 0:
            error('Directory: "%s" not found' % d)
            sys.exit(1)

        self.d = d = os.path.normpath(d) + os.path.sep
        self.songs = files and files or os.listdir(d)
        self.m4as  = conf.convert_m4a and filter(self.songs, '*.[mM]4[aA]') or []
        self.mp3s  = conf.convert_mp3 and filter(self.songs, '*.[mM][pP]3') or []
        self.wavs  = conf.convert_wav and filter(self.songs, '*.[wW][aA][vV]') or []
        self.wmas  = conf.convert_wma and filter(self.songs, '*.[wW][mM][aA]') or []
        self.flacs = conf.convert_flac and filter(self.songs, '*.[fF][lL][aA][cC]') or []

        if conf.verbose:
            self.printIfVerbose(conf)

        for f in self.wmas +  self.mp3s + self.wavs + self.m4as + self.flacs:
            Convert(d + f, conf)

    def printIfVerbose(self, conf):
        ''' Echo files to be converted if verbose flag is set.'''
        info('In %s I am going to convert:' % self.d)
        for i in ('mp3', 'flac', 'm4a', 'wma', 'wav'):
            if conf.__dict__['convert_' + i]:
                for mp3 in self.__dict__[i + 's']:
                    info(mp3)
                if len(self.__dict__[i + 's']) == 0:
                    warn('No %ss in %s' % (i, self.d))
        print


def showBanner():
    print 'dir2ogg %s, (C) Julian Andres Klode and Darren Kirby. Released under GPL' % __version__
    print

def showLicense(*args, **kwargs):
    print 'dir2ogg %s; released %s ' % (__version__, __date__)
    print
    print 'Copyright (C) 2007 Julian Andres Klode <jak@jak-linux.org>'
    print 'Copyright (C) 2003-2006 Darren Kirby <d@badcomputer.org>'
    print
    print 'This program is distributed in the hope that it will be useful,'
    print 'but WITHOUT ANY WARRANTY; without even the implied warranty of'
    print 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the'
    print 'GNU General Public License for more details.'
    print
    print 'Currently developed by Julian Andres Klode <jak@jak-linux.org>.'
    sys.exit(0)

def main():
    conf = MyConfig()
    if conf.recursive:
        rdirs = {}
        for directory in conf.args:
            if os.path.exists(directory) == 0:
                error('Directory: "%s" not found' % directory)
                sys.exit(1)
            rdirs.update(returnDirs(d))
        if len(rdirs) == 0:
            error('No files to convert!')
            sys.exit(1)
        for directory,files in rdirs.items():
            ConvertDirectory(conf, directory, files)

    elif conf.directory:
        for directory in conf.args:
            if os.path.exists(directory) == 0:
                error('Directory: "%s" not found' % directory)
                sys.exit(1)
        for directory in conf.args:
            ConvertDirectory(conf, directory)

    elif conf.cdda:
        discs = len(conf.args) and conf.args or ("/dev/cdrom",)
        for disc in discs:
            ConvertDisc(disc, conf)
    else:
        for filename in conf.args:
            if os.path.exists(filename) == 0:
                error('File: "%s" not found' % filename)
                sys.exit(1)
        for filename in conf.args:
            Convert(filename, conf)

    sys.exit(0)

if __name__ == '__main__':
    main()
